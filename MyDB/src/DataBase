#include "DataBase.hpp"
/*
数据库包括两个文件，一个是index，另一个是data，index保存指向data中的off_t;
index相当于一个保存指针的数组，数组下标就是哈希值，保存的指针指向data中的桶；

index开头保存data所在的地址的字符串，以及字符串长度，之后还有8字节的level以及len
用于支持动态增长与缩减；

index：
 ————————————————————————————————————————
| string size 8bit | data location string | level 8bit | next 8bit | index table size 8bit |…… <——后面是数据（off_t指针）
 ————————————————————————————————————————


data中需要处理空闲区间，空闲区间表存储于一个大根堆中，data最开始的8bit为指向此大根堆的off_t
 data:
 ————————————————————————————————
| DataEndOffset 8 bit|指向空闲区间表的off_t |  ……
 ————————————————————————————————

 大根堆的结构如下：
  ————————————————————————————————————————————————————————————————————————————
| 区间数 8bit | 最大空闲区间 （16bit, 一个指向区间开始的指针以及区间的大小）| （后面是大小次之的区间）……
 ————————————————————————————————————————————————————————————————————————————

	当需要在data中找到一个区间来放置桶时，先查找空闲区间表，如果能找到合适大小的区间，就将其切割为合适的
大小然后返回，如果没有合适的区间，就分配文件尾的空间。
	需要将桶占用的空间释放时，直接将桶占用的区间插入大根堆。
	当大根堆大小超过其所在区间大小，就将其所在区间插入自身，然后merge一次（碎片整理），
随后和分配桶一样找到一个大小相当于本身两倍的一块区间然后写入。
	每次将大根堆写回文件，都要运行一次merge；


桶的结构如下：
 ————————————————————————————————————————————
|桶结束的offset 8bit| 桶当前的空闲空间 8bit |  ……后面是长度为148bit * 16的空间，用于存储项目……
 ————————————————————————————————————————————

项目的结构如下：
 —————————————————————————————————————————————
| key哈希值 4bit| key 长度 8bit | key（长度固定128bit）| data offset 8bit  | 
 —————————————————————————————————————————————

 data结构：
  ———————————————————————————————————————————————————————
 |  data level 4bit（最大4096bit）| data len 4bit（最大4096bit）|  data 数据	…………		
  ———————————————————————————————————————————————————————

每次读取一个桶时都会从后往前遍历寻找对应的项目，找到后会存储到LRU中并返回，没找到时也将存储结果写到LRU。
桶的增长与再分配类似于大根堆。

*/


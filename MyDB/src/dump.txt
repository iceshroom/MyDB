
	int EditDATA_PushBack(hash_str & key, off_t data) {
		pthread_rwlock_wrlock(&rwlock);
		FD found(FindLocat(key));
		if(found.openSuccess()) {
			off_t loc = lseek(found.getfd(), 0, SEEK_CUR);
			int dataLevel;
			int dataLen;
			Read(found.getfd(), &dataLevel, sizeof(int));
			Read(found.getfd(), &dataLen, sizeof(int));
			if(dataLevel-dataLen < sizeof(data)) {
				pthread_rwlock_unlock(&rwlock);
				return FAILURE;
			}
			lseek(found.getfd(), loc+sizeof(int)*2+dataLen, SEEK_SET);
			Write(found.getfd(), &data, sizeof(data));
			dataLen += sizeof(data);
			lseek(found.getfd(), loc+sizeof(int), SEEK_SET);
			Write(found.getfd(), &dataLen, sizeof(int));
			pthread_rwlock_unlock(&rwlock);
			return SUCCESS;
		} else {
			pthread_rwlock_unlock(&rwlock);
			return FAILURE;
		}
	}

	int EditDATA_PopBack(hash_str & key) {
		pthread_rwlock_wrlock(&rwlock);
		FD found(FindLocat(key));
		if(found.openSuccess()) {
			off_t loc = lseek(found.getfd(), 0, SEEK_CUR);
			int dataLevel;
			int dataLen;
			Read(found.getfd(), &dataLevel, sizeof(int));
			Read(found.getfd(), &dataLen, sizeof(int));
			if(dataLen == 0) {
				pthread_rwlock_unlock(&rwlock);
				return FAILURE;
			}
			dataLen -= sizeof(off_t);
			lseek(found.getfd(), loc+sizeof(int), SEEK_SET);
			Write(found.getfd(), &dataLen, sizeof(int));
			pthread_rwlock_unlock(&rwlock);
			return SUCCESS;
		} else {
			pthread_rwlock_unlock(&rwlock);
			return FAILURE;
		}
	}

	int GetDATA_GetBack(hash_str & key, off_t & loc) {
		pthread_rwlock_rdlock(&rwlock);
		FD found(FindLocat(key));
		if(found.openSuccess()) {
			int dataLevel;
			int dataLen;
			Read(found.getfd(), &dataLevel, sizeof(int));
			Read(found.getfd(), &dataLen, sizeof(int));
			off_t origloc = lseek(found.getfd(), 0, SEEK_CUR);
			if(dataLen == 0) {
				pthread_rwlock_unlock(&rwlock);
				return FAILURE;
			}
			dataLen -= sizeof(off_t);
			lseek(found.getfd(), origloc+dataLen, SEEK_SET);
			Read(found.getfd(), &loc, sizeof(off_t));
			pthread_rwlock_unlock(&rwlock);
			return SUCCESS;
		} else {
			pthread_rwlock_unlock(&rwlock);
			return FAILURE;
		}
	}

	if(dump == "creat_table") {
					string name;
					lineis >> name;
					if(!name.empty() && lineis) {
						deal_create_table(name, lineis);
					} else {
						ServReturn("ERROR: CREAT_TABLE Too few parameters.", clientfd);
					}
				} else 

	static int deal_create_table(const string & tableName, istringstream & tableEle) {
	if(DM.isok()) {
		hash_str key = tableName;
		string data;
		string dump;
		while(tableEle) {
			tableEle >> dump;
			data += dump + " ";
		}
		data += tableName+"_DATA"+to_string(rand());
		item ins(data, TABLEHEAD);
		return DM.insert(key, ins);
	} else 
		return FAILURE;
}

int block_size = sizeof(int)+KEY_LEN+data.DataSize();
		block = new char [block_size];
		memset(block, 0, block_size);
		((int*)(block))[0] = block_size;
		char * loc = block+sizeof(int);
		memcpy(loc, key.c_str(), key.size());
		loc += KEY_LEN;
		memcpy(loc, data.getData(), data.DataSize());